\chapter{Research Results}
\section{Introduction}
This chapter presents the results of the research conducted to answer the research questions. The chapter is
divided into two sections, each corresponding to one of the research questions. The first section presents
the results of the research conducted to answer the first research question, while the second section
presents the results of the research conducted to answer the second research question.

\section{Research Sub-Question \#1: What are the primary technologies and components utilized in the QaaS web application, and
  how do they function together as a system, including both front-end and back-end infrastructure?}

There are 2 main parts of the \acrshort{qaas} app, the front-end and the back-end. The front-end is made in
Flutter, and the back-end is made in Node.js with TypeScript as the template. The back-end is hosted on Firebase Cloud Functions which are
used to connect and make \acrshort{http} calls to the internal \acrshort{api}s, and the front-end is hosted on Firebase Hosting.

\subsection{The QaaS App Infrastructure}

\subsubsection{Firebase}
% It was originally an independent company founded by Firebase, Inc.
% in 2011. It was then acquired by Google in 2014. Since then, it has become an integral part of Google's
% broader ecosystem of cloud services (\cite{firebase}). I
Firebase is a comprehensive platform for developing and managing web and mobile applications, created by
Google and is part of \acrshort{gcp} services. It is a \acrshort{baas} that provides developers with a
variety of tools and services to help with both back-end infrastructure and front-end capabilities without worrying
about managing servers or infrastructures. The services offered by Firebase (\textit{\cite{firebaseproducts}}) are
many, but for this thesis, it will only discuss the ones that are used by the \acrshort{qaas} app. They are listed
in the following:
\begin{itemize}
      \item Authentication: is an easy-to-understand authentication services that support various authentication
            methods like email/password, phone number, with identity providers such as Google, Facebook, Twitter,
            Apple, GitHub, \acrshort{etc}
            along with utilizing \acrshort{2fa} authentication factors to enhance security by requiring additional
            factor, such as an \acrshort{otp} code that is sent to the user's phone or security key. This functionality
            is used for the login screen of the \acrshort{qaas} App.
      \item Database:
            \begin{itemize}
                  \item Firestore Database: Firestore is a \gls{NoSQL} database that is part of the Firebase
                        platform. It is a flexible, scalable database for mobile, web, and server development. It keeps
                        data in sync across client apps through real-time listeners and offers offline support for mobile
                        and web, so the developers can build responsive apps that work regardless of network latency or
                        Internet connectivity. This will be used to store the user data from different \acrshort{api}s,
                        for example client's Microsoft subscription from Resello or \acrshort{qict} financial data
                        over the years from SnelStart.
            \end{itemize}
      \item Cloud Functions: often just called Functions in the Firebase console, it allows developers to run
            back-end code in response to events triggered by Firebase features and \acrshort{https} requests.
            The code is stored in Google's cloud and runs in a managed environment. It is a serverless framework
            that allows developers to build and deploy serverless functions that automatically scale up and down
            based on demand. The available programming languages are Node.js (\acrshort{js} and \acrshort{ts}),
            Python, Go, Java, and .NET (C\#). Cloud Functions offers 2 product versions: the original version
            (1st gen), and the 2nd gen which is built on Cloud Run and Eventarc to provide an enhanced feature set.
            \begin{itemize}
                  \item 1st Generation: Most of the Firebase Cloud Functions that are used in the \acrshort{qaas} app
                        is in this version. The company wishes to migrate all the functions to the 2nd generation in
                        the future. Furthermore, for the integration of SentinelOne with the \acrshort{qaas} app, the
                        company wishes to utilize the 2nd generation of Cloud Functions.
                  \item 2nd Generation: The company wishes that the author's graduation project will utilize the 2nd
                        generation of Cloud Functions.
                        % Features in the 2nd generation including:
                        % \begin{itemize}
                        %       \item Longer request processing times
                        %       \item Larger instance sizes
                        %       \item Traffic management
                        %       \item Eventarc integration
                        %       \item Broader CloudEvents support
                        % \end{itemize}
            \end{itemize}
            Cloud functions are the main back-end infrastructure of the \acrshort{qaas} app. It is used to connect
            and make \acrshort{http} calls to all the internal \acrshort{api}s. There are different types of
            functions in Firebase Cloud Functions, and they will be discussed later. Some functions are called within
            the app, and some outside of the app. Some functions are also used to listen to the Firestore collections,
            in case of any changes in the data.
\end{itemize}

\begin{longtable}{|p{5cm}|p{5.5cm}|p{5.5cm}|}
      \hline
      \rowcolor{blue!20}
      Feature         & 1st Gen                                                     & 2nd Gen                                                       \\
      \endfirsthead
      \hline
      Image registry  & Container Registry or Artifact Registry                     & Artifact Registry only                                        \\
      \hline
      Request timeout & Up to 9 minutes                                             & \begin{itemize}
                                                                                            \item Up to 60 minutes for \acrshort{http}-triggered functions
                                                                                            \item Up to 9 minutes for event-triggered functions
                                                                                      \end{itemize} \\
      \hline
      Instance Size   & Up to 8\acrshort{gb} \acrshort{ram} with 2 v\acrshort{vcpu} & Up to 16\acrshort{gb} \acrshort{ram} with 4 \acrshort{vcpu}   \\
      \hline
      Concurrency     & 1 concurrent request per functions instance                 & Up to 1000 concurrent requests per function instance          \\
      \hline
      \caption{Comparison between the 1st and 2nd Generation of Cloud Functions in Firebase}
      \label{tab:restvsoap}
\end{longtable}

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/Firebase/Extensions.png}
%       \caption{All the extensions that are used in the \acrshort{qaas} app, mostly about Algolia}
% \end{figure}

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/Firebase/App Check.png}
%       \caption{The App Check feature in the \acrshort{qaas} app}
% \end{figure}

\begin{itemize}
      \item Hosting: a service that allows developers to host static websites, dynamic web apps, mobile apps, and
            microservices on Firebase's infrastructure. The \acrshort{qaas} app is currently hosted on Firebase
            Hosting.
      \item Cloud Storage: offers secure, scalable, and reliable file storage and sharing for Firebase apps.
            It is designed to help developers quickly and easily store and serve user-generated content, such as
            photos or videos. It is used by the \acrshort{qaas} app to store and serve user-generated content, such as
            profile pictures, documents, and other files.
      \item Extensions: it consists pre-built, open-source software packages that extend the functionality of a Firebase
            project (\textit{\cite{firebaseExtension}}). They are designed to automate common development tasks, such as
            sending notifications, integrating with third-party services, and performing back-end operations, without
            requiring users to write custom code. The \acrshort{qaas} app uses the Extension mainly for Algolia.
      \item App Check: it is a security feature that, on top of Firebase \acrshort{2fa} Authentication, that helps protect
            the project from abuse, such as billing fraud or phishing, by ensuring that only the app that is registered
            can have access to the Firebase project's resources (\textit{\cite{appCheckFirebase}}). In the case of the
            \acrshort{qaas} app, it uses it \gls{reCAPTCHA} to ensure extra protection in the \acrshort{mfa}.
\end{itemize}

\begin{figure}[H]
      \centering
      \includegraphics[width=1.0\textwidth]{Figures/Firebase.png}
      \caption{All the products offered by Firebase (\textit{\cite{firebasePic}})}
\end{figure}

\textbf{Different Types of Cloud Functions in Firebase}

Firebase has a lot of different types of Cloud Functions that developers can use. Just like the previous Firebase product
explanation, this thesis will only focus on the following types of Cloud Functions that are used in the \acrshort{qaas} app:

\textbf{HTTP Triggers}: these are functions that are triggered by \acrshort{http} requests. They are used as \acrshort{api}
endpoints of the \acrshort{qaas} app, allowing server-side logic execution in response to \acrshort{http} requests from
client-side applications or external services. The requests are GET, POST, PUT, DELETE, and PATCH, and they are used to
creating, reading, updating, and deleting data in either the Firestore \acrshort{db} or the correlated \acrshort{api}
environment itself.

\begin{itemize}
      \item onRequest: this method is used to create an \acrshort{http} function that is triggered by an \acrshort{http}
            request. They are more general-purpose compared to Callable Functions and can be used to create \acrshort{rest}ful
            \acrshort{api}s, handle form submissions or perform any other server-side operations that require \acrshort{http}
            requests. Unlike Callable Functions, onRequest functions do not handle authentication or data serialization, so
            the developers need to manage this aspect manually. This functions only accepts \texttt{Request} and
            \texttt{Response}, but not \texttt{NextFunction}. In the context of \acrshort{qaas} app, this function is only used
            for testing purposes, and the developer will need to migrate to onCall when deploying on the Live environment.
\end{itemize}

\begin{lstlisting}[language=JavaScript, caption=Example of a typical onRequest function]
      import { Request, Response } from 'express';
      import * as functions from "firebase-functions/v2";

      const region = "europe-west1";

      export.getData = functions.https.onRequest({ region: region }, async (request: Request, response: Response): Promise<any> => {
            try {
                  const response = SentinelOneAPICall();
                  return response.status(200).json(data: response.data);
            } catch (ex: unknown) {
                  if (error instanceof Error) {
                        // Error object, log message and stack if available
                        console.error(`[${context}] An error occurred: ${error.message} \n Stack: ${error.stack}`);
                  } else {
                        // Non-Error object, log with a generic message.
                        console.error(`[${context}] An unknown error occurred:`, error);
                  }
                  response.status(500).send("Failed to retrieve agents");
            }
      });
\end{lstlisting}

\begin{itemize}
      \item onCall: is a little different from  \texttt{onRequest}. Instead of using \texttt{Request} and \texttt{Response}, it
            uses \texttt{data} and \texttt{context}. In version 2.0, it only accepts requests as \texttt{CallableRequest<any>} that can get
            any headers and body of the request sent by user. It is used to create Callable Functions, and they are designed to be called
            directly from client applications, such as mobile or web apps. They automatically handle authentication and data serialization,
            making it easier to secure call backend code from client applications, and this is what the \acrshort{qaas} app
            primarily uses for calling its internal \acrshort{api}s as it ensures that the client is authenticated and authorized
            to make the call. Callable functions are triggered by an \acrshort{http} request but are specifically designed to be
            called from Firebase client \acrshort{sdk}s.

\end{itemize}

\begin{lstlisting}[language=JavaScript, caption=Example of onCall function with authentication check]
      import * as functions from "firebase-functions/v2";
      const region = "europe-west1";

      const getData = functions.https.onCall({ region: region }, async (request: CallableRequest<any>) => {
            try {
                  // Checking that the user is authenticated.
                  if (!context.auth) {
                        // Throwing an HttpsError so that the client gets the error details.
                        throw new functions.https.HttpsError('failed-precondition', 'The function must be called while authenticated.');
                  }
                  const response = SentinelOneAPICall();
                  return {
                        data: response.data,
                  };
            } catch (ex: unknown) {
                  if (error instanceof Error) {
                        // Error object, log message and stack if available
                        console.error(`[${context}] An error occurred: ${error.message} \n Stack: ${error.stack}`);
                  } else {
                        // Non-Error object, log with a generic message.
                        console.error(`[${context}] An unknown error occurred:`, error);
                  }
                  throw new functions.https.HttpsError("unknown", "Failed to retrieve agents", ex);
            }
      });

      async function SentinelOneAPICall() : Promise<any> {
            const apiUrl = 'https://sentinelOne.example.com/users/123';

            // Define the request parameters
            const requestOptions = {
                  method: 'GET', // HTTP method (GET, POST, PUT, DELETE, PATCH, etc.)
                  headers: {
                        'Content-Type': 'application/json', // Set the content type of the request
                  }
            };
      
            // Make the API request
            fetch(apiUrl, requestOptions)
                  .then(response => response.json())
                  .then(data => console.log(data)) // Process the response data
                  .catch(error => console.log('error', error)); // Handle any errors that occurred during the request
      }
              
      export = getData;
\end{lstlisting}

\textbf{Pub/Sub Triggers}: are the functions triggered by messages published to a \acrshort{pubsub} topic.
It is a messaging service that enables decoupling of applications by sending messages between independent components.

\textbf{Scheduled functions}: this is a Firebase's own term for \gls{cronJob} (\textit{\cite{scheduleFunction}}).
They are used within the \acrshort{qaas} app to run tasks at regular intervals, such as sending reminders, keeping
data up-to-date with the internal \acrshort{api}s (like customer list), or performing maintenance tasks.

\begin{figure}[H]
      \centering
      \includegraphics[width=1.0\textwidth]{Figures/Firebase/Functions/CronJobs.png}
      \caption{The \textit{Scheduled Function}  in the \acrshort{qaas} app that is scheduled to run every 7 days to keep the \acrshort{api} data up-to-date
            (\textit{\cite{cronJobQaaSAppFunction}})}
\end{figure}

\textbf{Algolia}

Algolia is used for search functionality. It is a search-as-a-service platform that enables developers to
integrate and build fast, relevant search functionality into their applications and websites
(\textit{\cite{algolia}}). It provides a range of features and capabilities for building and managing search
functionality, including full-text search, typo tolerance, and relevance tuning, as well as analytics and
monitoring tools to help developers understand how users are interacting with their search functionality in
real-time.

The reason as to why \acrshort{qict} uses Algolia is that the nature of Firebase search engine is quite often
proven to be inaccurate and slow. It uses the traditional search engine that will look through fields in
\acrshort{json} format because of its \acrshort{nosql} nature. It often struggles with misspelled words or
incorrect queries. Algolia has a standout feature that to handle user typos and errors gracefully
through its \acrshort{ai}-powered search algorithms. Users often-times do not like to type the exact words for
something that they want to search for. This means that they make typos or enter incomplete search terms or its
abbreviation. Algolia's intelligent algorithms can interpret the intent behind the search and return accurate,
relevant results.

The Company Supervisor has expressed a desire to use Algolia in the \acrshort{qaas} app in multiple interviews
the author has undertaken for the analysis and designing of this project. It is a nice to have feature that
promotes user-friendliness and ease of use.

\begin{figure}[H]
      \centering
      \includegraphics[width=1.0\textwidth]{Figures/Algolia Seach.png}
      \caption{Example of Algolia search where the search query is wrong and incomplete, and it still gives
            the appropriate result (\textit{Laptop Manuel})}
\end{figure}

\textbf{Google Secret Manager}

It is a fully managed service provided by \acrshort{gcp} that allows developers and organization to securely store,
access, and manage sensitive information such as API keys, passwords, certificates, \acrshort{db} credentials and other
credentials used in throughout the lifecycle of their applications
(\textit{\cite{googlesecretmanager}}). It is not part of Firebase, and it helps the \acrshort{qaas} app to centralize and
secure its secrets in scalable and easily manageable way. Key-features of Secret Manager include:

\begin{itemize}
      \item Secure Storage: it encrypts the secret values using \acrshort{cmek}, ensuring the sensitive data is protected
            both at rest and in transit.
      \item Audit Logs: it provides and manages audit logs that record all access and modification of activities, helping
            developers meet compliance, better accountability and regulatory requirements.
      \item Versioning and Automatic Rotation: it supports versioning of secrets, allowing developers to store multiple versions
            of the same secret. This means that the developers get to keep multiple versions of secrets and easily revert or roll
            back to a previous version if needed, which will help in auditing and tracking changes to secrets over time. This feature
            enables automatic seamless rotation of secrets at regular intervals without  disrupting the applications, which improves
            the security part of the application by ensuring that secrets are regularly updated without manual intervention.
      \item Access Control: it provides fine-grained access control using Google \acrshort{iam}, allowing developers to specify
            who can access and manage the stored secrets and what they can do with them.
      \item Centralized Management: it stores and manages all secrets in one place, simplifying access and control.
\end{itemize}

Google Secret Manager comes from \acrshort{gcp}, and \acrshort{gcp} and Firebase are a separate cloud solution. But, because
both are part of Google, Firebase Cloud Functions can typically access \acrshort{gcp} Secret Manager by editing that specific function
that the developer wanted to grant access to. In the context of the \acrshort{qaas} App, Secret Manager is mostly used to store the
\acrshort{api} keys and tokens.

\begin{figure}[H]
      \centering
      \includegraphics[width=1.0\textwidth]{Figures/Secret Manager.png}
      \caption{The secrets in Secret Manager of the \acrshort{qaas} App environment}
\end{figure}

\begin{figure}[H]
      \centering
      \includegraphics[width=1.0\textwidth]{Figures/Secret Manager Actions.png}
      \caption{A secret in Secret Manager would have a version control, in which a user can view, disable, or destroy the latest version
            of the secret}
\end{figure}

\subsubsection{Modules and User Tags  of the QaaS App} % Templates

The \acrshort{qaas} has several user tags that are used to build the app. The tags can be interpreted as level of access to the app,
showing what permission a user has to the app. Because of coding inconsistency, there are 2 naming of functionality, which are user
tags and user roles, both serving the same purpose. User tags can be assigned or revoked to a user by the \acrshort{it} admin
willingly. User Tags can be revoked or assigned to users by \acrshort{it} admins in "Account Beheer" module. The user tags in
the \acrshort{qaas} App are the following:

\begin{itemize}
      \item Account beheer
      \item Besteller
      \item Budget aanpassen
      \item Budget overzicht
      \item Helpdesk
      \item \acrshort{ids} (for seeing \acrshort{ids} module)
      \item Intake overzicht
      \item Intake verwijderen
      \item Pakbon admin
      \item Periodevergelijking overzicht
      \item Periodevergelijking updaten
      \item User
\end{itemize}

% \begin{figure}[H]
%       \centering
%       \includegraphics[width=1.0\textwidth]{Figures/Qaas App/Modules/afbeelding (1).png}
%       \caption{Different user tags in the QaaS app in which the IT admin can determine which pages can be accessed by which user tags}
%       \label{fig:qaasAppModules}
% \end{figure}

% \begin{figure}[H]
%       \centering
%       \includegraphics[width=1.0\textwidth]{Figures/Qaas App/User tags.png}
%       \caption{An example of how a user tag can access certain pages in the Flutter code}
% \end{figure}

% \begin{figure}[H]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/Qaas App/User Tag Checker.png}
%       \caption{Check for the appropriate user tags in Firebase for extra database protection}
% \end{figure}

Modules are the page division of the \acrshort{qaas} app. They are interlinked with User Tags to create the navigation logic of the app.
All pages will have different functions, corresponding to its interconnected \acrshort{api}. Examples of modules in the \acrshort{qaas} app
are:

\begin{itemize}
      \item Klanten Koppeling
      \item \acrshort{ids} Systeem
      \item Budget Overzicht
      \item Intake Overzicht
      \item Account Beheer
      \item Periode Vergelijking
      \item Klanten
      \item Security (Bodyguard.io)
      \item Apparaten (N-Central)
      \item Abonementen
      \item Facturitatie
      \item Intake
      \item Pakbonnen
\end{itemize}

% \begin{figure}[H]
%       \centering
%       \includegraphics[width=1.0\textwidth]{Figures/QaaS Modules.png}
%       \caption{Examples of modules in the QaaS App (\#1)}
% \end{figure}

% \begin{figure}[H]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/QaaS Modules 2.png}
%       \caption{Examples of modules in the QaaS App (\#2) that a "User" user tag can access}
% \end{figure}

\subsection{Conclusion}
The \acrshort{qaas} app is an \acrshort{erp} web application that is used by \acrshort{qict} and its clients.
It is made in Dart with Flutter as the front-end framework, and Node.js with the back-end  framework with
TypeScript as a template to ensure type safety. The app uses several internal \acrshort{api}s and technologies to
help with its operations, such as Resello, SnelStart, Bodyguard.io, N-Central, and PerfectView. They all have different
purposes that in which make up the functionalities of the \acrshort{qaas} app. The back-end of \acrshort{qict} is Firebase that serves the
cloud solution. Firebase Cloud Functions are the primarily components used for making different \acrshort{http} connections to those 5
\acrshort{api}s. Firebase Hosting is used to host the front-end web application from the Flutter framework. The app also
uses other Firebase products, such as Authentication, Firestore Database, Cloud Functions, Hosting, Cloud
Storage, Extensions, App Check, and Google Secret Manager. The app also uses Algolia for search functionality. The app
has several templates and modules that are used for the authentication and authorization of the app.
The User tags can be viewed as a level of authorization within the \acrshort{qaas} App, and the modules are the pages
with different functionalities that the user can have access to. A user tag can be assigned to a module so that user
accounts that have that user tag can view the module. Together, they with the control flow of the app's features and functionalities,
and the \acrshort{it} Admin has the highest level of access and control over the app.

\section{Research Sub-Question \#2: What is SentinelOne EDR Platform?}
% vs CrowdStrike with Carbanak and FIN7 methodology, Huntresss, datto rmm

SentinelOne is a cybersecurity platform that provides endpoint protection, detection, and response capabilities to
help organizations defend against advanced cyber threats. It leverages \acrshort{ai} and \acrshort{ml} to analyze
and respond to security threats in real-time, providing organizations with comprehensive protection against malware,
ransomware, and other cyber threats. It also provides visibility into clients' \acrshort{it} systems and infrastructure,
enabling organizations to gain insights into potential security risks and vulnerabilities and take proactive measures
to address them.

Some terminology that the readers need to be familiar with before diving deeper into SentinelOne:

\textbf{Endpoint}

Endpoint can be defined as any remote computing devices that receives incoming communications and sends outgoing messages
to the network it is connected to. Examples of endpoints include desktops, laptops, smartphones, tablets, servers, workstations,
and other \acrshort{iot} devices that is connected to a network. They are the first-line of defence for the Blue Team today.

Examples of endpoints are:
\begin{itemize}
      \item Computer (workstations, desktops)
      \item Laptop
      \item Server
      \item Mobile devices
\end{itemize}

% \textbf{NGAV}

% \acrshort{ngav} is a cybersecurity solution designed to protect endpoints from malware by working  through siganture-based detection.
% Traditional \acrshort{av} usually identify and block known threats by comparing the fingerprint of a file to a database of known
% malicious ones. \acrshort{ngav} improves this by utilizing \acrshort{ai} and behavioural analysis t block known and unknown
% threats, including zero-day attacks, and other sophisticated maware that may evade signature detection. However, the scope of
% \acrshort{ngav} is limited to only prevention, and they do not give Security Teams the telemetry needed to address the rapidly
% evolving threat landscape.

% \textbf{EPP}

% \acrshort{epp} is also an upgrade from legacy \acrshort{av}/anti-malware. \acrshort{epp} consists of solutions that work together to detect
% and block security threats at the endpoint device level. An \acrshort{epp} solution contains a combination of \acrshort{ngav}s, focusing
% on providing tools designed to protect network-connected devices - endpoints - from malware, ransomware, and other cyber threats. It aims
% to provide holistic approach to securing endpoints, which include desktop, laptops, servers, and mobile devices, by combining multiple
% security functions into a single platform.

% The concept of \acrshort{epp} has evolved over time to include more advanced features and functionalities, leading to the emergence
% of other solutions such as Next-generation \acrshort{epp} (NG EPP), \acrshort{nges}, and \acrshort{ngfw}.

\textbf{EDR}

\acrshort{edr} \acrshort{aka} \acrshort{etdr}, is a group of integrated endpoint security solutions that combine data collection,
data analysis, forensics, and \gls{threathunting} with the end-goal of identifying and stopping any potential security breaches in due
time. \acrshort{edr} solutions can recognize any suspicious patterns that can be investigated later, as they have been
purposefully created to detect and respond in an active manner to advance malware, ransomware, and other cyber threats (the Response
\acrshort{edr}). \acrshort{edr}, as the name suggest, were developed specifically for endpoints, and not networks, thus
operate only on endpoint level.

The number one thing that sets apart \acrshort{edr} from traditional \acrshort{av} is that traditional \acrshort{av} relies on
signature-based detection, usually having a defined set of list in their \acrshort{db}, where known malware signatures are compared
against files or processes to identify threats. \acrshort{edr} on the other hand, uses a combination of signature-based detection, such
as behavioural analysis, machine learning, and anomaly detection to identify and respond both known and unknown threats. \acrshort{edr}
solutions focus on detecting malicious activities at the endpoint level, including file modifications, process execution, and network
connections, focusing on malicious behaviour compared to only concerning with malicious software like what traditional \acrshort{av} does.
While this seems similar to \acrshort{ngav}, what sets apart \acrshort{edr} from \acrshort{ngav} is that \acrshort{edr} solutions are
more focused on detecting and responding to threats after they have infiltrated the network, whereas \acrshort{ngav} aims only to
prevent threats from executing in the first place through advanced detection techniques, a functionality that is crucial in an \acrshort{av}.

% \textbf{MDR}

% \acrshort{mdr} is what manage the \acrshort{edr} technology. An \acrshort{mdr} will consist of multiple \acrshort{edr} solutions in
% which it adds the human role aspect to the operational framework necessary to effectively manage and respond to threats. For example,
% a \acrshort{mdr} service provider will have a team of security analysts that will monitor and respond to security alerts generated by
% the \acrshort{edr} solutions, then utilize their own experts to analyze alerts, investigate incidents, and execute responses.

% \textbf{NDR} \label{sec:ndr}
% \acrshort{ndr} products are designed to provide a complete visibility into the network, real-time detection of threats, and guided
% investigation to accelerate and automate responses (\textit{\cite{sentinelOneNDR}}). \acrshort{ndr} takes a feed of raw network traffic
% from a \gls{networkTap}, port mirror, or virtual traffic mirroring in \acrshort{aws} and Azure. By analyzing this traffic in real-time,
% \acrshort{ndr} finally discovers and classify every device communicating on the network. It identifies device roles, such as \acrshort{dns},
% web server, medical device, \acrshort{etc} and maps peer groups among those devices.

% \textbf{SIEM}

% is a software system that collects, aggregates, normalizes security data from a variety of sources within an IT infrastructure, and
% analyzes it according to pre-set rules, present it in human-readable format and therefore giving a comprehensive picture of the company's
% information security (\cite{siemGartner}). \acrshort{siem} tools evolved from the log management discipline and combine \acrshort{sim} and
% \acrshort{sem} technologies. A \acrshort{siem} tool uses \acrshort{ai} to automate several manual procedures related to threat
% detection and incident response. Furthermore, it assists enterprise security teams in spotting anomalies in user behavior.

% \begin{itemize}
%       \item Input: logs, threat intel, vulnerability feeds, \acrshort{ndr}, firewall, \acrshort{ips}, \acrshort{ids}, and \acrshort{edr}
%             data
%       \item Output: high-fidelity alerts prioritized by severity
%       \item Infused with: \acrshort{ai}, \acrshort{ml}, and analytics
% \end{itemize}

% \textbf{SOAR}

% \acrshort{soar} solutions focus on automating incident response processes and triage capabilities. The key word here is
% "orchestration" and "automation". In an ideal world, everything.
% The main goal is to oversee security without human help as much as possible, boosting productivity and shortening the response time.
% It might use \acrshort{ai} and \acrshort{ml} to assess security events and automate incident response procedures. These solutions
% can be standalone product, or it can be added to \acrshort{siem} solutions since \acrshort{soar} does not excel in event analysis.

% \textbf{XDR}

% is a security solution that gathers and analyzes data from multiple sources like endpoints, networks, cloud, emails, app,
% \acrshort{etc} It offers great visibility into a company's \acrshort{it} infrastructure, helping the security employees to detect
% more threats, respond efficiently, and deal with fewer false positive alerts \cite{xdrIDC}.

% This solution integrates several tools combining all the gathered data into a single platform to visualize the information. It might
% incorporate automated processes (even complex ones), \acrshort{ml}, and advanced analytics to enable quicker and more effective
% incident response. It can even deal with hidden and advanced malware.

% \textbf{MXDR}

% Some people may still call it \acrshort{mdr}, managed \acrshort{soc}, or managed security, it is an extension of \acrshort{mdr},
% providing more comprehensive coverage and capabilities to address the evolving cybersecurity landscape. It aims to cover a wider
% range of security concerns and employs more advance technologies for threat detection and prevention than \acrshort{mdr}, while
% also offering more proactive, engaging threat hunting and predicitive analysis to anticipate and prevent threats, whereas
% \acrshort{mdr} tends to be more reactive, focusing on responding to alerts.

% \textbf{SOC}

% \acrshort{soc} is the organizational context itself. It is a centralized facility or team within an organization that houses a
% security team responsible for monitoring and analyzing another organization's (client) security position on an ongoing basis. They
% can be seen as the safety team for client organizations. Please note that SentinelOne company itself is not a \acrshort{soc}, as it
% is just a cybersecurity company that offers endpoint security solutions.


\begin{figure}[H]
      \centering
      \includegraphics[width=0.8\textwidth]{Figures/XDR.jpg}
      \caption{How all terms related to various technologies in cybersecurity connected to each other}
      \label{fig:xdr}
\end{figure}

% \textit{Please note that as mentioned before, \acrshort{siem} can also take data from an \acrshort{edr} and \acrshort{ndr} but for
%       the sake of simplicity, the diagram puts them as a separate pier systems}. In terms of SentinelOne, it has all the features that
% are mentioned in the diagram, except for \acrshort{soc}, as was mentioned before.

\textbf{SentinelOne Console}

SentinelOne \acrshort{mgmt} Console is the \acrshort{gui} provided by SentinelOne for managing and administering the platform. It serves
as the primary dashboard for security operators and administrators to interact with SentinelOne product suite, enabling them to monitor,
configure, and respond to cybersecurity threats across their organization's endpoints, servers, and cloud environments.

\textbf{Global}

The Global tab refers to the environment of the highest level of advisors. It consists of organizations that have access to global level
that propagate down to the tenant level, which means they can put policies, scripts, and other configurations that will be applied to all
consoles and all their customers.

\textbf{Site}

Site is just a name that refers to logical grouping of devices that are managed together under a single administrative domain, or a company.
A company customer can have multiple sites, and each site can have multiple devices. Each site \acrshort{id} is unique and is used to
identify the site in the SentinelOne console.

\textbf{Group}

Group refers to logical grouping of devices within SentinelOne \acrshort{mgmt} Console.  It is a way to organize and manage collections
of endpoints, servers, and other entities within the platform. It allows admins to apply policies, deploy agents, and perform other
management tasks across a defined set of assets in an organized and efficient manner. This hierarchical structure is crucial for
managing large-scale deployments and ensuring that security policies and configurations are consistently applied across relevant assets.
Groups can be created and deleted by the admin user, and devices can be moved between groups. An example of a group in \acrshort{qict}
site is:

\begin{itemize}
      \item Default Group
      \item Laptops
      \item Workstations
      \item Servers
\end{itemize}

\textbf{Agents}

An Agent is a software program, part of SentinelOne product, that is deployed to each endpoint, including desktop, laptop,
server or virtual environment, and runs autonomously on each device, without reliance on Internet connection, enabling data
gathering, detection, and response to actions. Agents can be interpreted as an \acrshort{av}, collecting relevant security
telemetry such as:
\begin{itemize}
      \item Running processes
      \item Connected servers
      \item Open files
\end{itemize}
This information can be useful to detect the presence of a threat or to use in forensic analysis and investigation after
an attack has occurred (Recovery).

\textbf{Ranger}

Ranger is an add-on SentinelOne product that provides a way of detecting other devices (computers and
\acrshort{iot} devices) that are on the client's computer network. If a malicious attacker comes in and plugs his device
into the network, all the other SentinelOne agents are going to read the network traffic, determine and classify whether
that is a new device or a rogue device. If a device has Ranger on that network subnet, SentinelOne can gather and
detect technical information regarding the device.

\begin{itemize}
      \item Not reviewed
      \item Not trusted
      \item Under analysis
      \item Allowed
\end{itemize}

Ranger is designed to detect and take out malicious actors that are in the local subnet, as they can a lot of information about the
devices (\textit{see \acrshort{arp} Poisoning \cite{arpSpoofing} and man-in-the-middle-attack \cite{man-in-the-middleAttack}}).
In the real-business scenario, a lot of the times, a company has a very secure perimeter firewall
(\textit{the big outer castle wall in castle-and-moat network security model \cite{castleMoatWallNetwork}}), but the inside network
are wide open (unless they are doing logical separations of their local network, such as using \acrshort{vlan}) for attacks inside
the network.

Unfortunately for this project scope, Ranger \acrshort{api} calls are off limit, as the company is still considering if they would
that implemented in the application because turning it on will cause them more money. Therefore, displaying all the Ranger ability
to scan and the \acrshort{api} call of the author's account.

\textbf{Sentinels}

Sentinels refer to a term that describes SentinelOne ability to deploy and manage security agents on endpoints within an
organization, not part of SentinelOne product, like Ranger. This is part of the SentinelOne \acrshort{edr} capabilities,
where the user admin can deploy the agents on the endpoints and manage them from the SentinelOne console. The admin can
also create policies, scripts, and other configurations that will be applied to all the agents in the network.

\textbf{Visibility}

Unfortunately, \acrshort{qict} does not have Visibility turned on its tenant, thus this feature is also off limit for this project
scope. But in general, Visibility allows users to do deep querying to be able to identify different things, such as attributes of
a machine. It is useful when user is looking for threats or any additional information in Incident Response or \gls{threathunting},
which in most cases is proactive, Visibility can give the user a lot of power to use queries, and interrogate all the information
or telemetry that SentinelOne has pulled off from the connected machines.

\textbf{Incidents}

Incident is just the name of a page in SentinelOne dashboard that provides a list of cyber-incidents overview that have happened on all
endpoints detected by Agents in the network connected to SentinelOne by Ranger. The page typically offers an overview of all detected
security incidents, categorized based on severity levels of types of threats.

Once a threat is detected, the user can take the following actions in the dashboard, if they have enough privileges
to do so:
\begin{itemize}
      \item Kill: stops all processes related to that threat
      \item Quarantine: encrypts and moves the threat and its executables
      \item Remediate: deletes all files and system changes created by the threat
      \item Rollback: restores files and configuration that the threat changed. This step is usually taken when a malware has
            executed its script and has made changes to the system, \acrshort{eg} a ransomware has encrypted all the files and
            asked for a ransom. By taking this step, all the three previous steps will also be undertaken as well. This will
            then reboot the system and restore it to the safe state before the malware has been executed.
\end{itemize}

\textbf{Reports}

The reports in SentinelOne provide users with insights into the security posture and threat landscape across their organization's
endpoints. The reports offer customizable reporting capabilities, allowing users to generate reports tailored to their specific
requirements. Users can then choose from a variety of predefined report templates or create custom reports based on their unique
needs.

Furthermore, the users can also choose for the report to be made automatically, instead of manually filling them themselves. They can
schedule automated report generation at regular intervals, such as daily, weekly, or monthly.

\begin{figure}[htbp]
      \centering
      \includegraphics[width=1.0\textwidth]{Figures/SentinelOne/Reports.png}
      \caption{Examples of automatic reports that can be downloaded in SentinelOne}
      \label{fig:Reports}
\end{figure}

% \textbf{Vigilance}

% It is a \acrshort{mdr} service - providing threat monitoring, hunting, and response, to its existing customers. It
% provides a 24/7 \acrshort{soc} with expert analysts and researchers to give customers near real-time threat monitoring,
% in-console threat annotations, and response to threats and suspicious events. Vigilance itself is a separate package from
% SentinelOne that requires a separate purchase and subscription.

% \textbf{\textit{How does SentinelOne get all this information from a device without having them even connected to the Internet?}}

% On a network, before a machine is connected and talks to other devices and gateways, it is going to do a broadcast and gives up information about itself.
% This is called an \acrshort{arp} Request. As everything that is talking on Layer 2 is giving out their \acrshort{mac} address for exchange,
% SentinelOne is going to listen to that broadcast and then capture that information. This is how SentinelOne can get information about a device
% that is not connected to the Internet.

% A lot of the times, most switches and routers do not change their default credentials and are not configured properly, which makes it easy
% for an attacker to get in and do a malicious act.

% As was said before, every single item that is connected to a network is constantly broadcasting information out to the rest of
% network, in order to get and maintain an \acrshort{ip} address to keep accessing the Internet, even when it is not actively using
% it (\textit{see \acrshort{dhcp} Protocol \cite{dhcpProcess}}). In case of an endpoint that has SentinelOne installed on it that
% has Ranger, that Ranger is going to listen to that \acrshort{nic} on that device, then capture and interpret all the data that
% is flowing across the network, called \acrshort{mib}s, thus displaying it on the Console.

\subsection{Conclusion}

SentinelOne is a cybersecurity organization that provides \acrshort{edr} solutions for endpoint protection, detection, and response
capabilities to help organizations defend against advanced cyber threats. It leverages \acrshort{ai} and machine learning to
analyze and respond to security threats in real-time, providing organizations with comprehensive protection against
malware, ransomware, and other cyber threats. SentinelOne provides a wide range of features and capabilities, including
endpoint protection, detection, and response, as well as visibility into clients' \acrshort{it} systems and infrastructure.
SentinelOne has multiple components, such as Agents that are responsible for collecting security telemetry of an endpoint,
Ranger that is responsible for detecting other devices on the network, and other components that work together to provide
comprehensive security solutions for organizations. It is famous for its autonomous features and cloud-native architecture,
make it well-suited for securing modern \acrshort{it} environments against evolving cyber threats.

The integration of SentinelOne to the \acrshort{qaas} App will enhance its monitoring capabilities by providing real-time,
comprehensive visibility into the security status of clients' devices. This allows for aggregation of detailed threat
intelligence and device health information, enabling the app to display critical security data such as threat detections,
mitigations, and the overall security posture of each monitored device. By leveraging SentinelOne's advanced threat
detection and response features, the \acrshort{qaas} App can offer more proactive and efficient incident management,
ensuring that potential threats are swiftly identified and addressed. This not only boosts transparency for clients,
allowing them to view and understand insights into their device security, thereby enhancing their trust and confidence
in the cybersecurity provided by \acrshort{qict}.

\section{Research Sub-Question \#3: How can SentinelOne be integrated with the QaaS app?}

The integration of SentinelOne into the \acrshort{qaas} App is viable, leveraging the company's subscription through Pax8,
a partner of both Microsoft and \acrshort{qict}. This integration involves several key steps and consideration to ensure
a seamless and secure implementation.

Firstly, the deployment of SentinelOne Agents across the clients' endpoints is essential. These Agents are responsible
for collecting comprehensive endpoint data, including system health information, malware incidents, network connections,
and outdated applications posing security risks according to latest \acrshort{cve}s from the \acrshort{nist} and MITRE.
This data is then transmitted into the SentinelOne platform, forming a robust dataset for threat analysis and endpoint
management.

Once the Agents are operational and data is flowing into the SentinelOne ecosystem, the integration process involves
retrieving the real-time data into the \acrshort{qaas} environment itself. This is where the SentinelOne \acrshort{api}
come from. SentinelOne provides a \acrshort{rest}ful \acrshort{api} server to allow users to integrate SentinelOne with other
security tools and systems.

SentinelOne also provides a comprehensive documentation for its \acrshort{rest}ful \acrshort{api} that allows users to interact
with the SentinelOne platform programmatically. The \acrshort{api} provides a wide range of functionalities, including the ability
to retrieve information about devices, incidents, and threats, as well as the ability to perform actions such as quarantining devices,
remediating threats, and generating reports. The \acrshort{api} is designed to work with the Agents, Sentinels, Ranger, and other
components of the SentinelOne platform.

The \acrshort{api} sends requests to the associated Management Server and responds with the data that the management pulled from
the Agents or from the management database. Therefore, all the data that is displayed in the SentinelOne Console dashboard is also
available through the \acrshort{api}.

\subsection{API Token}

To be able to access SentinelOne \acrshort{api}s, the user needs to have an \acrshort{api} token to prove their
identity and that their organization has SentinelOne subscription, therefore has right to access data.
\acrshort{api} tokens can be created in the SentinelOne \acrshort{mgmt} Console.

The \acrshort{api} token will be shown only once; therefore, the user needs to store it in a secure place.
The token generated by the user is time-limited. To renew the token, the user must generate a new one with the same above-steps. The
\acrshort{api} token will need to be placed in secure environment, where it is there in the cloud to be accessed anywhere but not any
parties can have access to it by having an encryption. This is where Google Secret Manager will come into play.

\begin{figure}[htbp]
      \centering
      \includegraphics[width=0.8\textwidth]{Figures/SentinelOne/API Doc.png}
      \caption{SentinelOne API Documentation}
\end{figure}

\subsection{API Request from Cloud Functions}

Firebase Cloud Functions will act as a backend logic for fetching data from SentinelOne. With an \acrshort{npm} package called
\href{https://www.npmjs.com/package/@google-cloud/secret-manager}{\texttt{@google-cloud/secret-manager}}, the cloud Function
can then retrieve the stored \acrshort{api} key from Secret Manager and use it to authenticate \acrshort{api} requests to SentinelOne.
The appropriate \acrshort{api} \acrshort{url}s must be identified, which typically include \acrshort{url}s for retrieving endpoint,
malware, application details, and other relevant security metrics. The \acrshort{api} requests should include the necessary headers and
authorization tokens to ensure secure communication.

Upon successful retrieval of data, the backend

\subsection{API Limit}

The user needs to see the latest data from SentinelOne every time they refresh the page. Therefore, the dashboard will automatically
make a query to the Cloud Functions to fetch the data every time the page is refreshed.

SentinelOne has a number of limitation in its \acrshort{api}, which is 1.000 \acrshort{api} calls per minute. To combat this, the author
will instead store the queried data in Cloud Firestore for users to re-query. A limit will be set for about 30 minutes where the cloud
function will only query from Cloud Firestore, in which both the Cloud Function gen 2.0 and the Firestore have quota of querying. If
the \acrshort{api} limit is hit, the Cloud Function will automatically make a new query to SentinelOne \acrshort{api}, renew the data
in Firestore, and set the limit to 30 minutes again. This will make sure that the user will see the latest data from SentinelOne, with
the duration of 30 minutes, and can make unlimited amount of refreshing on the dashboard without breaking the \acrshort{api}. The limit
duration can be changed later by other developer if needed.

\subsection{Conclusion}
% SentinelOne provides a wide range of features and capabilities, including
% endpoint protection, detection, and response, as well as visibility into clients' \acrshort{it} systems and infrastructure.
SentinelOne provides a \acrshort{rest}ful \acrshort{api} that allows users to interact with the SentinelOne platform
programmatically, enabling integration with other security tools and systems. The \acrshort{api} provides a wide range of
functionalities, including the ability to retrieve information about devices, incidents, and threats, as well as the ability
to perform actions such as quarantining devices, remediating threats, and generating reports. The author will use the official
SentinelOne \acrshort{api} documentation to integrate SentinelOne with the \acrshort{qaas} app to display the data of
\acrshort{qict} and its 400 clients in the \acrshort{qaas} app. The functionality such as filtering, sorting, and pagination
will also be considered to make the data more user-friendly. The author will utilize different kinds of Firebase Cloud
Functions (\acrshort{http} onCall, Pub/Sub Triggers, Schedule functions) to call the SentinelOne \acrshort{api}s and display
data. Firestore will also be used to store the user's preference from the \acrshort{qaas} app, such as the user's choice of
what data they want to see, and visualization types. The author will also utilize Google Secret Manager to store the
\acrshort{api} token and other sensitive information securely, so it will not be displayed in the code to avoid any security
risks. Furthermore, \acrshort{ai} powered search engine Algolia will be used to search for specific data in the \acrshort{qaas} app,
as well as Firestore to make the search faster and more accurate.

\section{Research Sub-Question \#4: What are the best data visualization techniques for SentinelOne?}
Data visualization is the process of representing complex data (in the form of text and numbers) into a
graphical representation, such as: interactive charts, dashboards, pie charts, and so on. In the context
of this project, the displays should be able to tell interesting stories and share findings with diverse
audience (the client, helpdesk, and cybersecurity analysts).

\subsection{Data Visualization Widgets in Flutter}
In Flutter, there are 3 famous library that supports a wide range of chart types,
\href{https://pub.dev/packages/fl_chart}{fl\_chart},
\href{https://pub.dev/packages/syncfusion_flutter_charts}{syncfusion\_flutter\_charts}, and
\href{https://pub.dev/packages/flutter_echarts}{flutter\_echarts}. Each chart type is
suitable for a specific kind of data and provides a different way to visualize the data. Types of charts in
both libraries include 30+ plotting series:
\begin{itemize}
      \item Line chart: is used to display data points connected by straight line segments. They are commonly
            used to show trends over time.
      \item Bar chart: it uses rectangular bars to represent data. The length of each bar corresponds to the
            value it represents. Bar charts are useful for comparing quantities of different categories.
      \item Pie chart: represents data in the form of slices of a pie. Each slice corresponds to a category
            of the data, and the size of the slice is proportional to the quantity it represents.
      \item Scatter chart: uses dots to represent data points on a two-dimensional plane. They are useful
            for showing the relationship between two variables.
      \item Radar chart: \acrshort{aka} spider chart or star chart, is a way of comparing multiple
            quantitative variables. This makes them useful for seeing which variables have similar values
            or if there are any outliers among each variable.
\end{itemize}

\begin{figure}[htbp]
      \centering
      \includegraphics[width=0.8\textwidth]{Figures/Charts.png}
      \caption{Available charts in \texttt{fl\_chart} that will be useful in the visualization part of this project}
      \label{fig:charts}
\end{figure}

Each chart type is easily configured with built-in support for creating stunning visual effects, and any
number of series can be added to the chart. Features such as markers, data labels, data label builder,
animation, gradient fill, dashes, sorting, and annotations are easy to incorporate and customize.

Several main components of each chart type are:
\begin{itemize}
      \item Chart data: the most important part is the data that wanted to be displayed. This could be a simple
            list of numbers, or more complex data structure, depending on the type of chart.
      \item Chart type: the second most important part is to specify the type of chart.
      \item Axes: the x and y-axes of the chart. The axes provide a reference frame for the data points and
            can be customized to suit the user's needs.
      \item Grid: the grid lines on the chart. These lines can help users better understand the data by
            providing a reference frame.
      \item Touch response: the way the chart responds to user's touch events. It can be customized by
            providing different types of interactivities, such as highlighting a data point when it is touched.
\end{itemize}

\textbf{Axis Types}

Axis features such as label intersecting, edge label placement, label rotation, axis opposition, inverse
axis, and multiple axis allow users to customize axis elements to make an axis more readable. Four of the
axis types that are supported are:
\begin{itemize}
      \item Numeric
      \item Category
      \item Date-time
      \item Logarithmic
\end{itemize}

\textbf{User Interaction}

The packages greatly enhance \acrshort{ux} by adding the following functionalities:
\begin{itemize}
      \item Zooming and panning
      \item Crosshairs
      \item Trackballs
      \item Drilling down
      \item Events
      \item Selection
      \item Tooltips
\end{itemize}

\textbf{Legend}

The packages also support legends, which display additional information about a chart series. The legends
can be used to collapse the series and can be wrapped or scrolled if items exceed the available bounds.

\subsection{Comparison to other EDR solutions}
To determine the best visualization techniques for SentinelOne, a comparison to other \acrshort{edr}
solutions is needed. In this section, the author has looked into other alternatives to SentinelOne, which are
a single \acrshort{epp}/\acrshort{edr} solution, created as a complete replacement of legacy \acrshort{av}.
Please keep in mind that in this sub-question, only visualization techniques and features of the solutions
will be assessed, compared, contrasted, evaluated, and discussed. Factors such as pricing and technologies
will not be discussed in this sub-question. The author also does not have access to the actual dashboards,
therefore pictures of the dashboards are likewise taken from the Internet or are available from the official
website. This is because \acrshort{qict} is not utilizing these solutions, setting up an account and getting
access to the dashboards will raise the project's budget, which is not feasible.

\subsubsection{CrowdStrike}

CrowdStrike is an American cybersecurity company based in Austin, Texas, that provides cloud workload and
endpoint security, threat intelligence, and cyberattack response service. In the dashboard, CrowdStrike
offers fully customizable widgets to ensure that the various roles on security teams are provided with
the information that they need. The dashboard allows static prebuilt widgets that can be moved around on
a page, and customizable data views that enable each individual widget to be tailored for the users.

Features of CrowdStrike dashboard including:

\begin{itemize}
      \item \textbf{Role assignment}: allows the user to assign roles to the users, so that they can see
            the data that is relevant to their role. For example, \acrshort{it} admins are allowed to have
            an eye on the status of the CrowdStrike Falcon Sensors within the environment. This enables them
            to  understand if there are any gaps and allows them to remediate any issues. A \acrshort{soc}
            analysts, executives, and vulnerability analysts can easily see any security threats detected
            or blocked.
      \item \textbf{Fully customizable}: widgets can be customized to display just the right data needed.
            Users can add filters and change the lens with which to view the data, from donut to line charts.
      \item \textbf{Advance dynamic filtering options}: filters can be applied dynamically to the dashboard,
            with data from a single source. This could help analysts focus on the most important criteria
            in their \gls{threathunting}.
      \item \textbf{Customized Scheduled Reports}: reports based off dashboards or other data sources can
            be generated and sent automatically on a specified schedule.
\end{itemize}

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/CrowdStrike/visualization-widgets.png}
%       \caption{Visualization widgets in CrowdStrike}
% \end{figure}

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/CrowdStrike/add-widget.png}
%       \caption{Adding a widget in CrowdStrike}
% \end{figure}


% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/CrowdStrike/Scheduled_Report.png}
%       \caption{Create scheduled report in CrowdStrike}
% \end{figure}


\subsubsection{Trend Micro} % Fukujima
It is an American Japanese cybersecurity software company, providing cloud and enterprise cybersecurity in
environments like \acrshort{aws}, Microsoft, and Google Trend Micro Apex One has customizable contents and
layout of their dashboard. Workload Security uses Session to save user's settings and remember the last view
of the dashboard the next time the user logs in. The colour shown in the dashboard is more basic compared to
the other solution with only the typical red, green, blue, and yellow. Components of the
Trend Micro dashboard is:

\begin{itemize}
      \item \textbf{Tabs}: are the container for widgets. Tabs can be added or modified as needed. A dashboard
            can support up to 10 tags, and each tab can hold up to 10 widgets.
      \item \textbf{Widgets}: like other solutions, widgets represent the core components of the dashboard.
            They contain visual charts and graphs that track threats and associate them with log statistics
            aggregated from one or several gateways.
      \item \textbf{Event}: contains a log of record when a protection module rule or condition is triggered
            by Deep Security Agents. CrowdStrike Agents and Deep Security Manager also records when
            administrative or system-related events occur (a "system event"), such as administrator logging,
            or agent software being upgraded. Even data is used to populate the various reports and graphs
            in Deep Security Manager.
      \item \textbf{Filter by tags}: in CrowdStrike Deep Security\textregistered, a tag is a unit of meta-data
            that can be applied to an Event to create an additional attribute for the Event that is not
            originally contained within the Event itself. Tags can be used to filter Events to simplify
            the task of the Event monitoring and management. A typical use of tagging is to distinguish between
            Events that require action and those that have been investigated and found to be benign.
      \item \textbf{Filter by date and time range}: allows the user to filter the data by date and time range.
            For example, data can be displayed from either the last 24 hours, or the last 7 days.
\end{itemize}


% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/Trend Micro/dashboard-1.png}
%       \caption{Dashboard in Trend Micro}
% \end{figure}

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/Trend Micro/tABS.jpg}
%       \caption{A Tab in Trend Micro can contain up to 10 widgets}
% \end{figure}

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/Trend Micro/darg-and-drop.png}
%       \caption{Change the layout of the dashboard in Trend Micro by dragging and dropping the widgets}
% \end{figure}

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/Trend Micro/date-time-range.png}
%       \caption{Filter the data by date and time range in Trend Micro}
% \end{figure}

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/Trend Micro/path.png}
%       \caption{Add a tag to the data in Trend Micro}
% \end{figure}

% \subsubsection{Heimdal\textregistered{} And Huntress}

% Other \acrshort{edr} solutions to compare are Heimdal and Huntress. The author is not going to get deep into details of
% the 2, as they have have similar features to the previous 2 solutions. Heimdal is a Danish cybersecurity company that
% provides a range of security solutions, including endpoint security, network security, and email security. Huntress, on
% the other hand an American cybersecurity company that provides \acrshort{edr} solution that is fully managed and
% monitored 24/7 by human \acrshort{soc}, who detect and investigate alerts, triage alerts, and provide actionable
% remediation steps or one-click solutions. On the homepage,  information about each of the products/modules that are
% active under the current customer account is shown. The chart,  which can be seen include a variety of Bar charts, Pie
% charts, and Line charts, include data regarding attacks,  vulnerabilities, detections, infected/quarantined files,
% blocked/allowed processes, third-party application  vulnerabilities or \acrshort{os} updates, and quarantined/rejected
% e-mails. Like the previous 2 solutions, they also have customizable dashboard that allows users to add, remove, and
% rearrange widgets to suit their needs. The  dashboard also has filtering based on date time or other criteria. Furthermore,
% there are access roles within Heimdal (admin and customer) that allow the user to see only the data that is relevant to
% their role.

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.8\textwidth]{Figures/Heimdal/Home.png}
%       \caption{The dashboard of Heimdal\textregistered{}}
% \end{figure}

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.9\textwidth]{Figures/Huntress/dashboard.png}
%       \caption{The dashboard of Huntress}
% \end{figure}

% \begin{figure}[htbp]
%       \centering
%       \includegraphics[width=0.9\textwidth]{Figures/Huntress/incidents.png}
%       \caption{Seeing incidents in Huntress}
% \end{figure}


\subsection{Conclusion}
In Flutter, there are three main libraries that support a wide range of chart types, which are: fl\_chart,
flutter\_echarts, and syncfusion\_flutter\_charts. Each chart type is suitable for a specific kind of data
and provides a different way to visualize the data. The SentinelOne data will mainly be displayed by using
pie chart and bar graph because the data is categorical and numerical. Comparing to the other \acrshort{edr}
platform, the dashboard of the \acrshort{qaas} app should have customizable widgets, allowing users to
choose which data they want to display, how they want to display it, and where they want to display it on
the dashboard. The dashboard should also store user's preferences and settings, so that the user can see
the same view the next time they log in. The colour of visualization charts should not be more than the
typical red, green, blue, and yellow, as it can be overwhelming and confusing to the user. Red colour is
usually used to indicate a problem or a threat,  green colour is used to indicate that everything is okay,
while grey colour is used to indicate that the data is neutral or not critical, or that the data is not
available. Different colours such as purple, blue, and yellow will also be used to indicate different
categories of data. Additionally, the dashboard should also have a legend to display additional information
about the chart series. Filtering, sorting, and searching the data should be added to the dashboard to make
the data more user-friendly and interactive.


